{-# LANGUAGE GeneralizedNewtypeDeriving, TypeFamilies, DerivingStrategies, DerivingVia, FlexibleInstances, MultiParamTypeClasses, UndecidableInstances, StandaloneDeriving #-}
{-# LANGUAGE LambdaCase, RecordWildCards, TupleSections #-}
{-# LANGUAGE TemplateHaskell #-}
module Concordium.Skov.PersistentMonadImplementations where

import Control.Monad
import Control.Monad.Trans.State.Strict hiding (gets)
import Control.Monad.State.Class
import Control.Monad.State.Strict
import Control.Monad.RWS.Strict
import Lens.Micro.Platform
import Data.Time.Clock (NominalDiffTime)
import Data.Semigroup
import Data.IORef

import Concordium.GlobalState.Finalization
import Concordium.GlobalState.BlockState
import Concordium.GlobalState.TreeState
import Concordium.GlobalState.Parameters
import qualified Concordium.GlobalState.Persistent.TreeState as Persistent
import qualified Concordium.GlobalState.Persistent.BlockState as Persistent
import qualified Concordium.GlobalState.Basic.Block as Basic
import Concordium.GlobalState.Persistent.BlobStore
import Concordium.Skov.Monad
import Concordium.Skov.Query
import Concordium.Skov.Update
import Concordium.Skov.Hooks
import Concordium.Logger
import Concordium.TimeMonad
import Concordium.Afgjort.Finalize
import Concordium.Afgjort.Buffer

data FinalizationOutputEvent
    = BroadcastFinalizationMessage !FinalizationMessage
    | BroadcastFinalizationRecord !FinalizationRecord

-- |An instance of 'FinalizationEvent' can be constructed from a
-- 'FinalizationOutputEvent'.  These events are generated by finalization.
class FinalizationEvent w where
    embedFinalizationEvent :: FinalizationOutputEvent -> w
    embedCatchUpTimerEvent :: Maybe NominalDiffTime -> w
    extractFinalizationOutputEvents :: w -> [FinalizationOutputEvent]
    extractCatchUpTimer :: w -> Maybe (Maybe NominalDiffTime)

class FinalizationEvent w => BufferedFinalizationEvent w where
    embedNotifyEvent :: NotifyEvent -> w
    extractNotifyEvents :: w -> [NotifyEvent]

newtype SkovFinalizationEvents = SkovFinalizationEvents (Endo [FinalizationOutputEvent], Maybe (Maybe (Min NominalDiffTime)))
    deriving (Semigroup, Monoid)

instance FinalizationEvent SkovFinalizationEvents where
    embedFinalizationEvent = SkovFinalizationEvents . (, mempty) . Endo . (:)
    embedCatchUpTimerEvent = SkovFinalizationEvents . (mempty, ) . Just . fmap Min
    extractFinalizationOutputEvents (SkovFinalizationEvents (Endo f, _)) = f []
    extractCatchUpTimer (SkovFinalizationEvents (_, z)) = fmap (fmap getMin) z

newtype BufferedSkovFinalizationEvents = BufferedSkovFinalizationEvents (Endo [FinalizationOutputEvent], Maybe (Maybe (Min NominalDiffTime)), Endo [NotifyEvent])
    deriving (Semigroup, Monoid)

instance FinalizationEvent BufferedSkovFinalizationEvents where
    embedFinalizationEvent = BufferedSkovFinalizationEvents . (, mempty, mempty) . Endo . (:)
    embedCatchUpTimerEvent = BufferedSkovFinalizationEvents . (mempty, , mempty) . Just . fmap Min
    extractFinalizationOutputEvents (BufferedSkovFinalizationEvents (Endo f, _, _)) = f []
    extractCatchUpTimer (BufferedSkovFinalizationEvents (_, z, _)) = fmap (fmap getMin) z

instance BufferedFinalizationEvent BufferedSkovFinalizationEvents where
    embedNotifyEvent = BufferedSkovFinalizationEvents . (mempty, mempty, ) . Endo . (:)
    extractNotifyEvents (BufferedSkovFinalizationEvents (_, _, Endo f)) = f []



-- |This wrapper endows a monad that implements 'TreeStateMonad' with
-- an instance of 'SkovQueryMonad'.
newtype TSSkovWrapper m a = TSSkovWrapper {runTSSkovWrapper :: m a}
    deriving (Functor, Applicative, Monad, BlockStateOperations, BlockStateQuery, TreeStateMonad, TimeMonad, LoggerMonad)
type instance BlockPointer (TSSkovWrapper m) = BlockPointer m
type instance UpdatableBlockState (TSSkovWrapper m) = UpdatableBlockState m
type instance PendingBlock (TSSkovWrapper m) = PendingBlock m

instance (TreeStateMonad m) => SkovQueryMonad (TSSkovWrapper m) where
    {-# INLINE resolveBlock #-}
    resolveBlock = doResolveBlock
    {-# INLINE isFinalized #-}
    isFinalized = doIsFinalized
    {-# INLINE lastFinalizedBlock #-}
    lastFinalizedBlock = fst <$> getLastFinalized
    {-# INLINE getBirkParameters #-}
    getBirkParameters = doGetBirkParameters
    {-# INLINE getGenesisData #-}
    getGenesisData = Concordium.GlobalState.TreeState.getGenesisData
    {-# INLINE genesisBlock #-}
    genesisBlock = getGenesisBlockPointer
    {-# INLINE getCurrentHeight #-}
    getCurrentHeight = doGetCurrentHeight
    {-# INLINE branchesFromTop #-}
    branchesFromTop = doBranchesFromTop
    {-# INLINE getBlocksAtHeight #-}
    getBlocksAtHeight = doGetBlocksAtHeight

newtype TSSkovUpdateWrapper s m a = TSSkovUpdateWrapper {runTSSkovUpdateWrapper :: m a}
    deriving (Functor, Applicative, Monad, BlockStateOperations,
            BlockStateQuery, TreeStateMonad, TimeMonad, LoggerMonad,
            MonadState s, MonadIO)
    deriving SkovQueryMonad via (TSSkovWrapper m)
type instance BlockPointer (TSSkovUpdateWrapper s m) = BlockPointer m
type instance UpdatableBlockState (TSSkovUpdateWrapper s m) = UpdatableBlockState m
type instance PendingBlock (TSSkovUpdateWrapper s m) = PendingBlock m

instance (Monad m, OnSkov m) => OnSkov (TSSkovUpdateWrapper s m) where
  {-# INLINE onBlock #-}
  onBlock bp = TSSkovUpdateWrapper (onBlock bp)
  {-# INLINE onFinalize #-}
  onFinalize fin bp = TSSkovUpdateWrapper (onFinalize fin bp)
  {-# INLINE logTransfer #-}
  logTransfer = TSSkovUpdateWrapper $ do
    logTransfer >>= \case
      Nothing -> return Nothing
      Just lm -> return (Just (\bh slot reason -> TSSkovUpdateWrapper (lm bh slot reason)))

instance (TimeMonad m, LoggerMonad m, TreeStateMonad m, MonadIO m,
        MonadState s m, OnSkov m) 
            => SkovMonad (TSSkovUpdateWrapper s m) where
    storeBlock = doStoreBlock
    storeBakedBlock = doStoreBakedBlock
    receiveTransaction tr = doReceiveTransaction tr 0
    finalizeBlock = doFinalizeBlock

data PersistentContext = PersistentContext {
    pcBlobStore :: !BlobStore,
    pcModuleCache :: !(IORef Persistent.ModuleCache)
}

instance HasBlobStore PersistentContext where
    blobStore = blobStore . pcBlobStore

instance Persistent.HasModuleCache PersistentContext where
    moduleCache = pcModuleCache

data PersistentFinalizationContext = PersistentFinalizationContext {
    pfcBlobStore :: !BlobStore,
    pfcModuleCache :: !(IORef Persistent.ModuleCache),
    pfcFinalizationInstance :: !FinalizationInstance
}

instance HasBlobStore PersistentFinalizationContext where
    blobStore = blobStore . pfcBlobStore

instance Persistent.HasModuleCache PersistentFinalizationContext where
    moduleCache = pfcModuleCache




-- |The 'SkovQueryM' wraps 'RWST' to provide an instance of 'SkovQueryMonad'
-- when the state implements 'SkovLenses'.
newtype SkovQueryM r s m a = SkovQueryM {runSkovQueryM :: RWST r () s m a}
    deriving (Functor, Applicative, Monad, TimeMonad, LoggerMonad, MonadState s, MonadReader r, MonadIO)
    deriving BlockStateQuery via (Persistent.SkovTreeState r s (RWST r () s m))
    deriving BlockStateOperations via (Persistent.SkovTreeState r s (RWST r () s m))
    deriving TreeStateMonad via (Persistent.SkovTreeState r s (RWST r () s m))
    deriving SkovQueryMonad via (TSSkovWrapper (Persistent.SkovTreeState r s (RWST r () s m)))
-- UndecidableInstances is required to allow these type instance declarations.
type instance BlockPointer (SkovQueryM r s m) = BlockPointer (Persistent.SkovTreeState r s (RWST r () s m))
type instance UpdatableBlockState (SkovQueryM r s m) = UpdatableBlockState (Persistent.SkovTreeState r s (RWST r () s m))
type instance PendingBlock (SkovQueryM r s m) = PendingBlock (Persistent.SkovTreeState r s (RWST r () s m))

-- |Evaluate an action in the 'SkovQueryM'.  This is intended for
-- running queries against the state (i.e. with no updating side-effects).
evalSkovQueryM :: (Monad m) => SkovQueryM r s m a -> r -> s -> m a
evalSkovQueryM (SkovQueryM a) ctxt st = fst <$> evalRWST a ctxt st

-- * Without transaction hooks

-- |Skov state without finalizion.
data SkovPassiveState = SkovPassiveState {
    _spsSkov :: !Persistent.SkovData,
    _spsFinalization :: !PassiveFinalizationState
}
makeLenses ''SkovPassiveState

instance Persistent.SkovLenses SkovPassiveState where
    skov = spsSkov
instance PassiveFinalizationStateLenses SkovPassiveState where
    pfinState = spsFinalization

initialSkovPassiveState :: RuntimeParameters -> GenesisData -> Persistent.PersistentBlockState -> SkovPassiveState
initialSkovPassiveState rtParams gen initBS = SkovPassiveState{..}
    where
        _spsSkov = Persistent.initialSkovData rtParams gen initBS
        _spsFinalization = initialPassiveFinalizationState (bpHash (Persistent._skovGenesisBlockPointer _spsSkov))

newtype SkovPassiveM m a = SkovPassiveM {unSkovPassiveM :: RWST PersistentContext () SkovPassiveState m a}
    deriving (Functor, Applicative, Monad, TimeMonad, LoggerMonad, MonadState SkovPassiveState, MonadIO, MonadReader PersistentContext)
    deriving (BlockStateQuery, BlockStateOperations, TreeStateMonad) via (Persistent.SkovTreeState PersistentContext SkovPassiveState (SkovPassiveM m))
    deriving (SkovQueryMonad, SkovMonad) via (TSSkovUpdateWrapper SkovPassiveState (SkovPassiveM m))
type instance UpdatableBlockState (SkovPassiveM m) = Persistent.PersistentBlockState
type instance BlockPointer (SkovPassiveM m) = Persistent.PersistentBlockPointer
type instance PendingBlock (SkovPassiveM m) = Basic.PendingBlock

instance Monad m => OnSkov (SkovPassiveM m) where
    {-# INLINE onBlock #-}
    onBlock _ = return ()
    {-# INLINE onFinalize #-}
    onFinalize fr _ = spsFinalization %= execState (passiveNotifyBlockFinalized fr)
    {-# INLINE logTransfer #-}
    logTransfer = return Nothing

evalSkovPassiveM :: (Monad m) => SkovPassiveM m a -> PersistentContext -> RuntimeParameters -> GenesisData -> Persistent.PersistentBlockState -> m a
evalSkovPassiveM (SkovPassiveM a) pctx rtParams gd bs0 = fst <$> evalRWST a pctx (initialSkovPassiveState rtParams gd bs0)

runSkovPassiveM :: (Monad m) => SkovPassiveM m a -> PersistentContext -> SkovPassiveState -> m (a, SkovPassiveState)
runSkovPassiveM (SkovPassiveM a) pctx s = (\(res, s', _) -> (res, s')) <$> runRWST a pctx s

-- |Skov state with active finalization.
data SkovActiveState = SkovActiveState {
    _sasSkov :: !Persistent.SkovData,
    _sasFinalization :: !FinalizationState
}
makeLenses ''SkovActiveState

instance Persistent.SkovLenses SkovActiveState where
    skov = sasSkov
instance FinalizationStateLenses SkovActiveState where
    finState = sasFinalization

initialSkovActiveState :: FinalizationInstance -> RuntimeParameters -> GenesisData -> Persistent.PersistentBlockState -> SkovActiveState
initialSkovActiveState finInst rtParams gen initBS = SkovActiveState{..}
    where
        _sasSkov = Persistent.initialSkovData rtParams gen initBS
        _sasFinalization = initialFinalizationState finInst (bpHash (Persistent._skovGenesisBlockPointer _sasSkov)) (genesisFinalizationParameters gen)

newtype SkovActiveM m a = SkovActiveM {unSkovActiveM :: RWST PersistentFinalizationContext SkovFinalizationEvents SkovActiveState m a}
    deriving (Functor, Applicative, Monad, TimeMonad, LoggerMonad, MonadState SkovActiveState, MonadReader PersistentFinalizationContext, MonadWriter SkovFinalizationEvents, MonadIO)
    deriving (BlockStateQuery, BlockStateOperations, TreeStateMonad) via (Persistent.SkovTreeState PersistentFinalizationContext SkovActiveState (SkovActiveM m))
    deriving (SkovQueryMonad, SkovMonad) via (TSSkovUpdateWrapper SkovActiveState (SkovActiveM m) )
type instance UpdatableBlockState (SkovActiveM m) = Persistent.PersistentBlockState
type instance BlockPointer (SkovActiveM m) = Persistent.PersistentBlockPointer
type instance PendingBlock (SkovActiveM m) = Basic.PendingBlock
instance (TimeMonad m, LoggerMonad m, MonadIO m) => OnSkov (SkovActiveM m) where
    {-# INLINE onBlock #-}
    onBlock = notifyBlockArrival
    {-# INLINE onFinalize #-}
    onFinalize = notifyBlockFinalized
    {-# INLINE logTransfer #-}
    logTransfer = return Nothing

instance (TimeMonad m, LoggerMonad m, MonadIO m) 
            => FinalizationMonad SkovActiveState (SkovActiveM m) where
    broadcastFinalizationMessage = tell . embedFinalizationEvent . BroadcastFinalizationMessage
    broadcastFinalizationRecord = tell . embedFinalizationEvent . BroadcastFinalizationRecord
    getFinalizationInstance = pfcFinalizationInstance <$> ask
    resetCatchUpTimer = tell . embedCatchUpTimerEvent

runSkovActiveM :: SkovActiveM m a -> PersistentFinalizationContext -> SkovActiveState -> m (a, SkovActiveState, SkovFinalizationEvents)
runSkovActiveM (SkovActiveM a) fi fs = runRWST a fi fs


-- |Skov state with buffered finalization.
data SkovBufferedState = SkovBufferedState {
    _sbsSkov :: !Persistent.SkovData,
    _sbsFinalization :: !FinalizationState,
    _sbsBuffer :: !FinalizationBuffer
}
makeLenses ''SkovBufferedState

instance Persistent.SkovLenses SkovBufferedState where
    skov = sbsSkov
instance FinalizationStateLenses SkovBufferedState where
    finState = sbsFinalization
instance FinalizationBufferLenses SkovBufferedState where
    finBuffer = sbsBuffer

initialSkovBufferedState :: FinalizationInstance -> RuntimeParameters -> GenesisData -> Persistent.PersistentBlockState -> SkovBufferedState
initialSkovBufferedState finInst rtParams gen initBS = SkovBufferedState{..}
    where
        _sbsSkov = Persistent.initialSkovData rtParams gen initBS
        _sbsFinalization = initialFinalizationState finInst (bpHash (Persistent._skovGenesisBlockPointer _sbsSkov)) (genesisFinalizationParameters gen)
        _sbsBuffer = emptyFinalizationBuffer

newtype SkovBufferedM m a = SkovBufferedM {unSkovBufferedM :: RWST PersistentFinalizationContext BufferedSkovFinalizationEvents SkovBufferedState m a}
    deriving (Functor, Applicative, Monad, TimeMonad, LoggerMonad, MonadState SkovBufferedState, MonadReader PersistentFinalizationContext, MonadWriter BufferedSkovFinalizationEvents, MonadIO)
    deriving (BlockStateQuery, BlockStateOperations, TreeStateMonad) via (Persistent.SkovTreeState PersistentFinalizationContext SkovBufferedState (SkovBufferedM m))
    deriving (SkovQueryMonad, SkovMonad) via (TSSkovUpdateWrapper SkovBufferedState (SkovBufferedM m))
type instance UpdatableBlockState (SkovBufferedM m) = Persistent.PersistentBlockState
type instance BlockPointer (SkovBufferedM m) = Persistent.PersistentBlockPointer
type instance PendingBlock (SkovBufferedM m) = Basic.PendingBlock
instance (TimeMonad m, LoggerMonad m, MonadIO m) => OnSkov (SkovBufferedM m) where
    {-# INLINE onBlock #-}
    onBlock = notifyBlockArrival
    {-# INLINE onFinalize #-}
    onFinalize = notifyBlockFinalized
    {-# INLINE logTransfer #-}
    logTransfer = return Nothing

instance (TimeMonad m, LoggerMonad m, MonadIO m) 
            => FinalizationMonad SkovBufferedState (SkovBufferedM m) where
    broadcastFinalizationMessage msg = bufferFinalizationMessage msg >>= \case
            Left n -> tell $ embedNotifyEvent n
            Right msgs -> forM_ msgs $ tell . embedFinalizationEvent . BroadcastFinalizationMessage
    broadcastFinalizationRecord = tell . embedFinalizationEvent . BroadcastFinalizationRecord
    getFinalizationInstance = pfcFinalizationInstance <$> ask
    resetCatchUpTimer = tell . embedCatchUpTimerEvent

runSkovBufferedM :: SkovBufferedM m a -> PersistentFinalizationContext -> SkovBufferedState -> m (a, SkovBufferedState, BufferedSkovFinalizationEvents)
runSkovBufferedM (SkovBufferedM a) fi fs = runRWST a fi fs


-- * With transaction hooks

-- |Skov state with passive finalizion and transaction hooks.
-- This keeps finalization messages, but does not process them.
data SkovPassiveHookedState = SkovPassiveHookedState {
    _sphsSkov :: !Persistent.SkovData,
    _sphsFinalization :: !PassiveFinalizationState,
    _sphsHooks :: !TransactionHooks
}
makeLenses ''SkovPassiveHookedState

instance Persistent.SkovLenses SkovPassiveHookedState where
    skov = sphsSkov
instance PassiveFinalizationStateLenses SkovPassiveHookedState where
    pfinState = sphsFinalization
instance TransactionHookLenses SkovPassiveHookedState where
    hooks = sphsHooks

initialSkovPassiveHookedState :: RuntimeParameters -> GenesisData -> Persistent.PersistentBlockState -> SkovPassiveHookedState
initialSkovPassiveHookedState rtParams gen initBS = SkovPassiveHookedState{..}
    where
        _sphsSkov = Persistent.initialSkovData rtParams gen initBS
        _sphsFinalization = initialPassiveFinalizationState (bpHash (Persistent._skovGenesisBlockPointer _sphsSkov))
        _sphsHooks = emptyHooks

newtype SkovPassiveHookedM m a = SkovPassiveHookedM {unSkovPassiveHookedM :: RWST PersistentContext () SkovPassiveHookedState m a}
    deriving (Functor, Applicative, Monad, TimeMonad, LoggerMonad, MonadState SkovPassiveHookedState, MonadReader PersistentContext, MonadIO)
    deriving (BlockStateQuery, BlockStateOperations, TreeStateMonad) via (Persistent.SkovTreeState PersistentContext SkovPassiveHookedState (SkovPassiveHookedM m))
    deriving (SkovQueryMonad, SkovMonad) via (TSSkovUpdateWrapper SkovPassiveHookedState (SkovPassiveHookedM m))
type instance UpdatableBlockState (SkovPassiveHookedM m) = Persistent.PersistentBlockState
type instance BlockPointer (SkovPassiveHookedM m) = Persistent.PersistentBlockPointer
type instance PendingBlock (SkovPassiveHookedM m) = Basic.PendingBlock

instance (TimeMonad m, LoggerMonad m, MonadIO m) => OnSkov (SkovPassiveHookedM m) where
    {-# INLINE onBlock #-}
    onBlock bp = hookOnBlock bp
    {-# INLINE onFinalize #-}
    onFinalize fr bp = do
        sphsFinalization %= execState (passiveNotifyBlockFinalized fr)
        hookOnFinalize fr bp

    {-# INLINE logTransfer #-}
    logTransfer = return Nothing

evalSkovPassiveHookedM :: (Monad m) => SkovPassiveHookedM m a -> PersistentContext -> RuntimeParameters -> GenesisData -> Persistent.PersistentBlockState -> m a
evalSkovPassiveHookedM (SkovPassiveHookedM a) ctxt rtParams gd bs0 = fst <$> evalRWST a ctxt (initialSkovPassiveHookedState rtParams gd bs0)

runSkovPassiveHookedM :: (Monad m) => SkovPassiveHookedM m a -> PersistentContext -> SkovPassiveHookedState -> m (a, SkovPassiveHookedState)
runSkovPassiveHookedM (SkovPassiveHookedM a) ctxt s = (\(res, s', _) -> (res, s')) <$> runRWST a ctxt s

-- |Skov state with buffered finalization and transaction hooks.
data SkovBufferedHookedState = SkovBufferedHookedState {
    _sbhsSkov :: !Persistent.SkovData,
    _sbhsFinalization :: !FinalizationState,
    _sbhsBuffer :: !FinalizationBuffer,
    _sbhsHooks :: !TransactionHooks
}
makeLenses ''SkovBufferedHookedState

instance Persistent.SkovLenses SkovBufferedHookedState where
    skov = sbhsSkov
instance FinalizationStateLenses SkovBufferedHookedState where
    finState = sbhsFinalization
instance FinalizationBufferLenses SkovBufferedHookedState where
    finBuffer = sbhsBuffer
instance TransactionHookLenses SkovBufferedHookedState where
    hooks = sbhsHooks

initialSkovBufferedHookedState :: FinalizationInstance -> RuntimeParameters -> GenesisData -> Persistent.PersistentBlockState -> SkovBufferedHookedState
initialSkovBufferedHookedState finInst rtParams gen initBS = SkovBufferedHookedState{..}
    where
        _sbhsSkov = Persistent.initialSkovData rtParams gen initBS
        _sbhsFinalization = initialFinalizationState finInst (bpHash (Persistent._skovGenesisBlockPointer _sbhsSkov)) (genesisFinalizationParameters gen)
        _sbhsBuffer = emptyFinalizationBuffer
        _sbhsHooks = emptyHooks

newtype SkovBufferedHookedM m a = SkovBufferedHookedM {unSkovBufferedHookedM :: RWST PersistentFinalizationContext BufferedSkovFinalizationEvents SkovBufferedHookedState m a}
    deriving (Functor, Applicative, Monad, TimeMonad, LoggerMonad, MonadState SkovBufferedHookedState, MonadReader PersistentFinalizationContext, MonadWriter BufferedSkovFinalizationEvents, MonadIO)
    deriving (BlockStateQuery, BlockStateOperations, TreeStateMonad) via (Persistent.SkovTreeState PersistentFinalizationContext SkovBufferedHookedState (SkovBufferedHookedM m))
    deriving (SkovQueryMonad, SkovMonad) via (TSSkovUpdateWrapper SkovBufferedHookedState (SkovBufferedHookedM m) )
type instance UpdatableBlockState (SkovBufferedHookedM m) = Persistent.PersistentBlockState
type instance BlockPointer (SkovBufferedHookedM m) = Persistent.PersistentBlockPointer
type instance PendingBlock (SkovBufferedHookedM m) = Basic.PendingBlock
instance (TimeMonad m, LoggerMonad m, MonadIO m) => OnSkov (SkovBufferedHookedM m) where
    {-# INLINE onBlock #-}
    onBlock bp = do
        notifyBlockArrival bp
        hookOnBlock bp
    {-# INLINE onFinalize #-}
    onFinalize bp fr = do
        notifyBlockFinalized bp fr
        hookOnFinalize bp fr

    {-# INLINE logTransfer #-}
    logTransfer = return Nothing

instance (TimeMonad m, LoggerMonad m, MonadIO m) 
            => FinalizationMonad SkovBufferedHookedState (SkovBufferedHookedM m) where
    broadcastFinalizationMessage msg = bufferFinalizationMessage msg >>= \case
            Left n -> tell $ embedNotifyEvent n
            Right msgs -> forM_ msgs $ tell . embedFinalizationEvent . BroadcastFinalizationMessage
    broadcastFinalizationRecord = tell . embedFinalizationEvent . BroadcastFinalizationRecord
    getFinalizationInstance = pfcFinalizationInstance <$> ask
    resetCatchUpTimer = tell . embedCatchUpTimerEvent

runSkovBufferedHookedM :: SkovBufferedHookedM m a -> PersistentFinalizationContext -> SkovBufferedHookedState -> m (a, SkovBufferedHookedState, BufferedSkovFinalizationEvents)
runSkovBufferedHookedM (SkovBufferedHookedM a) fi fs = runRWST a fi fs


data PersistentFinalizationLoggedContext = PersistentFinalizationLoggedContext {
    pflcBlobStore :: BlobStore,
    pflcModuleCache :: IORef Persistent.ModuleCache,
    pflcFinalizationInstance :: FinalizationInstance,
    pflcLogMethod :: Maybe (LogTransferMethod IO)
}

instance HasBlobStore PersistentFinalizationLoggedContext where
    blobStore = pflcBlobStore

instance Persistent.HasModuleCache PersistentFinalizationLoggedContext where
    moduleCache = pflcModuleCache


newtype SkovBufferedHookedLoggedM m a = SkovBufferedHookedLoggedM {
  unSkovBufferedHookedLoggedM :: RWST PersistentFinalizationLoggedContext BufferedSkovFinalizationEvents SkovBufferedHookedState m a
  }
    deriving (Functor, Applicative, Monad, TimeMonad, LoggerMonad, MonadState SkovBufferedHookedState, MonadReader PersistentFinalizationLoggedContext, MonadWriter BufferedSkovFinalizationEvents, MonadIO, ATLMonad)
    deriving (BlockStateQuery, BlockStateOperations, TreeStateMonad) via (Persistent.SkovTreeState PersistentFinalizationLoggedContext SkovBufferedHookedState (SkovBufferedHookedLoggedM m))
    deriving (SkovQueryMonad, SkovMonad) via (TSSkovUpdateWrapper SkovBufferedHookedState (SkovBufferedHookedLoggedM m) )
type instance UpdatableBlockState (SkovBufferedHookedLoggedM m) = Persistent.PersistentBlockState
type instance BlockPointer (SkovBufferedHookedLoggedM m) = Persistent.PersistentBlockPointer
type instance PendingBlock (SkovBufferedHookedLoggedM m) = Basic.PendingBlock
instance (TimeMonad m, LoggerMonad m, MonadIO m) => OnSkov (SkovBufferedHookedLoggedM m) where
    {-# INLINE onBlock #-}
    onBlock bp = do
        notifyBlockArrival bp
        hookOnBlock bp
    {-# INLINE onFinalize #-}
    onFinalize bp fr = do
        notifyBlockFinalized bp fr
        hookOnFinalize bp fr

    {-# INLINE logTransfer #-}
    logTransfer =
      asks pflcLogMethod >>= \case
        Nothing -> return Nothing
        Just lm -> return (Just (\bh slot reason -> liftIO (lm bh slot reason)))


instance (TimeMonad m, LoggerMonad m, MonadIO m) 
            => FinalizationMonad SkovBufferedHookedState (SkovBufferedHookedLoggedM m) where
    broadcastFinalizationMessage msg = bufferFinalizationMessage msg >>= \case
            Left n -> tell $ embedNotifyEvent n
            Right msgs -> forM_ msgs $ tell . embedFinalizationEvent . BroadcastFinalizationMessage
    broadcastFinalizationRecord = tell . embedFinalizationEvent . BroadcastFinalizationRecord
    getFinalizationInstance = asks pflcFinalizationInstance
    resetCatchUpTimer = tell . embedCatchUpTimerEvent

runSkovBufferedHookedLoggedM :: SkovBufferedHookedLoggedM m a -> PersistentFinalizationLoggedContext -> SkovBufferedHookedState -> m (a, SkovBufferedHookedState, BufferedSkovFinalizationEvents)
runSkovBufferedHookedLoggedM (SkovBufferedHookedLoggedM a) ctxt fs = do
  runRWST a ctxt fs
