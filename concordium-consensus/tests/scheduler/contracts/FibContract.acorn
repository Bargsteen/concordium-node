module FibContract where

import Prod
import Maybe
import Prim
import List
import Blockchain
import Unit
import Bool
import Ord
import Map
import IntMap

data MsgFib = Fib [Int64]

definition mkReturn = Prod.Pair [Map.Map Int64 Int64] [Prim.Transaction]

definition baseValues = IntMap.insert [Int64] 0 1 (IntMap.insert [Int64] 1 1 (IntMap.empty [Int64]))

definition lookup = IntMap.lookup [Int64]

contract Fibonacci where

  init (ia :: Unit.Unit) (c :: Blockchain.InitContext) (addr :: {address}) (amount :: Amount) =
    baseValues

  receive (c :: Blockchain.ReceiveContext) (model :: Map.Map Int64 Int64) (caller :: Blockchain.Caller) (amount :: Amount) (msg :: Maybe.Maybe MsgFib) =
    case msg of
      Maybe.Nothing -> mkReturn model Prim.TxNone
      Maybe.Just msg' -> 
          case msg' of
              Fib n ->
                let addr = Blockchain.receiveSelfAddress c in
                case castFibonacci addr of
                  Maybe.Nothing -> mkReturn model Prim.TxReject
                  Maybe.Just i -> 
                    let amodel = getFibonacci i in
                    case lookup n amodel of
                      Maybe.Just _ -> mkReturn amodel Prim.TxNone -- if the value is already in the cache don't do anything
                      Maybe.Nothing -> 
                        case Prim.compareInt64 n 2 of
                          Ord.LT -> mkReturn amodel Prim.TxNone
                          _ -> 
                             case lookup (Prim.minusInt64 n 1) amodel of
                               Maybe.Nothing ->
                                 mkReturn amodel (Prim.TxBatch (sendFibonacci i (Fib (Prim.minusInt64 n 1)) amount)
                                                               (sendFibonacci i (Fib n) amount))
                               Maybe.Just v -> -- the value already exists, now check for n-2
                                 case lookup (Prim.minusInt64 n 2) amodel of
                                   Maybe.Nothing -> mkReturn amodel (Prim.TxBatch
                                                                      (sendFibonacci i (Fib (Prim.minusInt64 n 2)) amount)
                                                                      (Prim.TxBatch (sendFibonacci i (Fib (Prim.minusInt64 n 1)) amount)
                                                                                    (sendFibonacci i (Fib n) amount)))
                                   Maybe.Just u -> mkReturn (IntMap.insert [Int64] n (Prim.plusInt64 u v) amodel) Prim.TxNone

