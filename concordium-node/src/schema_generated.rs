// automatically generated by the FlatBuffers compiler, do not modify

use std::{cmp::Ordering, mem};

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod network {

    use std::{cmp::Ordering, mem};

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;

    #[allow(non_camel_case_types)]
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum PacketType {
        NONE             = 0,
        DirectMessage    = 1,
        BroadcastMessage = 2,
    }

    const ENUM_MIN_PACKET_TYPE: u8 = 0;
    const ENUM_MAX_PACKET_TYPE: u8 = 2;

    impl<'a> flatbuffers::Follow<'a> for PacketType {
        type Inner = Self;

        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for PacketType {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = u8::to_le(self as u8);
            let p = &n as *const u8 as *const PacketType;
            unsafe { *p }
        }

        #[inline]
        fn from_little_endian(self) -> Self {
            let n = u8::from_le(self as u8);
            let p = &n as *const u8 as *const PacketType;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for PacketType {
        type Output = PacketType;

        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<PacketType>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_PACKET_TYPE: [PacketType; 3] = [
        PacketType::NONE,
        PacketType::DirectMessage,
        PacketType::BroadcastMessage,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_PACKET_TYPE: [&'static str; 3] = ["NONE", "DirectMessage", "BroadcastMessage"];

    pub fn enum_name_packet_type(e: PacketType) -> &'static str {
        let index = e as u8;
        ENUM_NAMES_PACKET_TYPE[index as usize]
    }

    pub struct PacketTypeUnionTableOffset {}
    #[allow(non_camel_case_types)]
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum NetworkMessagePayload {
        NONE          = 0,
        NetworkPacket = 1,
    }

    const ENUM_MIN_NETWORK_MESSAGE_PAYLOAD: u8 = 0;
    const ENUM_MAX_NETWORK_MESSAGE_PAYLOAD: u8 = 1;

    impl<'a> flatbuffers::Follow<'a> for NetworkMessagePayload {
        type Inner = Self;

        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for NetworkMessagePayload {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = u8::to_le(self as u8);
            let p = &n as *const u8 as *const NetworkMessagePayload;
            unsafe { *p }
        }

        #[inline]
        fn from_little_endian(self) -> Self {
            let n = u8::from_le(self as u8);
            let p = &n as *const u8 as *const NetworkMessagePayload;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for NetworkMessagePayload {
        type Output = NetworkMessagePayload;

        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<NetworkMessagePayload>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_NETWORK_MESSAGE_PAYLOAD: [NetworkMessagePayload; 2] = [
        NetworkMessagePayload::NONE,
        NetworkMessagePayload::NetworkPacket,
    ];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_NETWORK_MESSAGE_PAYLOAD: [&'static str; 2] = ["NONE", "NetworkPacket"];

    pub fn enum_name_network_message_payload(e: NetworkMessagePayload) -> &'static str {
        let index = e as u8;
        ENUM_NAMES_NETWORK_MESSAGE_PAYLOAD[index as usize]
    }

    pub struct NetworkMessagePayloadUnionTableOffset {}
    pub enum DirectMessageOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct DirectMessage<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DirectMessage<'a> {
        type Inner = DirectMessage<'a>;

        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> DirectMessage<'a> {
        pub const VT_TARGET: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DirectMessage { _tab: table }
        }

        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DirectMessageArgs,
        ) -> flatbuffers::WIPOffset<DirectMessage<'bldr>> {
            let mut builder = DirectMessageBuilder::new(_fbb);
            builder.add_target(args.target);
            builder.finish()
        }

        #[inline]
        pub fn target(&self) -> u64 {
            self._tab
                .get::<u64>(DirectMessage::VT_TARGET, Some(0))
                .unwrap()
        }
    }

    pub struct DirectMessageArgs {
        pub target: u64,
    }
    impl<'a> Default for DirectMessageArgs {
        #[inline]
        fn default() -> Self { DirectMessageArgs { target: 0 } }
    }
    pub struct DirectMessageBuilder<'a: 'b, 'b> {
        fbb_:   &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DirectMessageBuilder<'a, 'b> {
        #[inline]
        pub fn add_target(&mut self, target: u64) {
            self.fbb_
                .push_slot::<u64>(DirectMessage::VT_TARGET, target, 0);
        }

        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DirectMessageBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DirectMessageBuilder {
                fbb_:   _fbb,
                start_: start,
            }
        }

        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DirectMessage<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum BroadcastMessageOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct BroadcastMessage<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BroadcastMessage<'a> {
        type Inner = BroadcastMessage<'a>;

        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> BroadcastMessage<'a> {
        pub const VT_IDS_TO_EXCLUDE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BroadcastMessage { _tab: table }
        }

        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BroadcastMessageArgs<'args>,
        ) -> flatbuffers::WIPOffset<BroadcastMessage<'bldr>> {
            let mut builder = BroadcastMessageBuilder::new(_fbb);
            if let Some(x) = args.ids_to_exclude {
                builder.add_ids_to_exclude(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn ids_to_exclude(&self) -> Option<flatbuffers::Vector<'a, u64>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(
                    BroadcastMessage::VT_IDS_TO_EXCLUDE,
                    None,
                )
        }
    }

    pub struct BroadcastMessageArgs<'a> {
        pub ids_to_exclude: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    }
    impl<'a> Default for BroadcastMessageArgs<'a> {
        #[inline]
        fn default() -> Self {
            BroadcastMessageArgs {
                ids_to_exclude: None,
            }
        }
    }
    pub struct BroadcastMessageBuilder<'a: 'b, 'b> {
        fbb_:   &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BroadcastMessageBuilder<'a, 'b> {
        #[inline]
        pub fn add_ids_to_exclude(
            &mut self,
            ids_to_exclude: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u64>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                BroadcastMessage::VT_IDS_TO_EXCLUDE,
                ids_to_exclude,
            );
        }

        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BroadcastMessageBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BroadcastMessageBuilder {
                fbb_:   _fbb,
                start_: start,
            }
        }

        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BroadcastMessage<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum NetworkPacketOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct NetworkPacket<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NetworkPacket<'a> {
        type Inner = NetworkPacket<'a>;

        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> NetworkPacket<'a> {
        pub const VT_MESSAGE: flatbuffers::VOffsetT = 10;
        pub const VT_NETWORKID: flatbuffers::VOffsetT = 8;
        pub const VT_PACKETTYPE: flatbuffers::VOffsetT = 6;
        pub const VT_PACKETTYPE_TYPE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NetworkPacket { _tab: table }
        }

        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args NetworkPacketArgs<'args>,
        ) -> flatbuffers::WIPOffset<NetworkPacket<'bldr>> {
            let mut builder = NetworkPacketBuilder::new(_fbb);
            if let Some(x) = args.message {
                builder.add_message(x);
            }
            if let Some(x) = args.packetType {
                builder.add_packetType(x);
            }
            builder.add_networkId(args.networkId);
            builder.add_packetType_type(args.packetType_type);
            builder.finish()
        }

        #[inline]
        pub fn packetType_type(&self) -> PacketType {
            self._tab
                .get::<PacketType>(NetworkPacket::VT_PACKETTYPE_TYPE, Some(PacketType::NONE))
                .unwrap()
        }

        #[inline]
        pub fn packetType(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    NetworkPacket::VT_PACKETTYPE,
                    None,
                )
        }

        #[inline]
        pub fn networkId(&self) -> u16 {
            self._tab
                .get::<u16>(NetworkPacket::VT_NETWORKID, Some(0))
                .unwrap()
        }

        #[inline]
        pub fn message(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    NetworkPacket::VT_MESSAGE,
                    None,
                )
                .map(|v| v.safe_slice())
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn packetType_as_direct_message(&self) -> Option<DirectMessage<'a>> {
            if self.packetType_type() == PacketType::DirectMessage {
                self.packetType().map(|u| DirectMessage::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn packetType_as_broadcast_message(&self) -> Option<BroadcastMessage<'a>> {
            if self.packetType_type() == PacketType::BroadcastMessage {
                self.packetType()
                    .map(|u| BroadcastMessage::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct NetworkPacketArgs<'a> {
        pub packetType_type: PacketType,
        pub packetType:      Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub networkId:       u16,
        pub message:         Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for NetworkPacketArgs<'a> {
        #[inline]
        fn default() -> Self {
            NetworkPacketArgs {
                packetType_type: PacketType::NONE,
                packetType:      None,
                networkId:       0,
                message:         None,
            }
        }
    }
    pub struct NetworkPacketBuilder<'a: 'b, 'b> {
        fbb_:   &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> NetworkPacketBuilder<'a, 'b> {
        #[inline]
        pub fn add_packetType_type(&mut self, packetType_type: PacketType) {
            self.fbb_.push_slot::<PacketType>(
                NetworkPacket::VT_PACKETTYPE_TYPE,
                packetType_type,
                PacketType::NONE,
            );
        }

        #[inline]
        pub fn add_packetType(
            &mut self,
            packetType: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                NetworkPacket::VT_PACKETTYPE,
                packetType,
            );
        }

        #[inline]
        pub fn add_networkId(&mut self, networkId: u16) {
            self.fbb_
                .push_slot::<u16>(NetworkPacket::VT_NETWORKID, networkId, 0);
        }

        #[inline]
        pub fn add_message(
            &mut self,
            message: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(NetworkPacket::VT_MESSAGE, message);
        }

        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> NetworkPacketBuilder<'a, 'b> {
            let start = _fbb.start_table();
            NetworkPacketBuilder {
                fbb_:   _fbb,
                start_: start,
            }
        }

        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NetworkPacket<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum NetworkMessageOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct NetworkMessage<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NetworkMessage<'a> {
        type Inner = NetworkMessage<'a>;

        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> NetworkMessage<'a> {
        pub const VT_PAYLOAD: flatbuffers::VOffsetT = 8;
        pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NetworkMessage { _tab: table }
        }

        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args NetworkMessageArgs,
        ) -> flatbuffers::WIPOffset<NetworkMessage<'bldr>> {
            let mut builder = NetworkMessageBuilder::new(_fbb);
            builder.add_timestamp(args.timestamp);
            if let Some(x) = args.payload {
                builder.add_payload(x);
            }
            builder.add_payload_type(args.payload_type);
            builder.finish()
        }

        #[inline]
        pub fn timestamp(&self) -> u64 {
            self._tab
                .get::<u64>(NetworkMessage::VT_TIMESTAMP, Some(0))
                .unwrap()
        }

        #[inline]
        pub fn payload_type(&self) -> NetworkMessagePayload {
            self._tab
                .get::<NetworkMessagePayload>(
                    NetworkMessage::VT_PAYLOAD_TYPE,
                    Some(NetworkMessagePayload::NONE),
                )
                .unwrap()
        }

        #[inline]
        pub fn payload(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    NetworkMessage::VT_PAYLOAD,
                    None,
                )
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn payload_as_network_packet(&self) -> Option<NetworkPacket<'a>> {
            if self.payload_type() == NetworkMessagePayload::NetworkPacket {
                self.payload().map(|u| NetworkPacket::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct NetworkMessageArgs {
        pub timestamp:    u64,
        pub payload_type: NetworkMessagePayload,
        pub payload:      Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for NetworkMessageArgs {
        #[inline]
        fn default() -> Self {
            NetworkMessageArgs {
                timestamp:    0,
                payload_type: NetworkMessagePayload::NONE,
                payload:      None,
            }
        }
    }
    pub struct NetworkMessageBuilder<'a: 'b, 'b> {
        fbb_:   &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> NetworkMessageBuilder<'a, 'b> {
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u64) {
            self.fbb_
                .push_slot::<u64>(NetworkMessage::VT_TIMESTAMP, timestamp, 0);
        }

        #[inline]
        pub fn add_payload_type(&mut self, payload_type: NetworkMessagePayload) {
            self.fbb_.push_slot::<NetworkMessagePayload>(
                NetworkMessage::VT_PAYLOAD_TYPE,
                payload_type,
                NetworkMessagePayload::NONE,
            );
        }

        #[inline]
        pub fn add_payload(
            &mut self,
            payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(NetworkMessage::VT_PAYLOAD, payload);
        }

        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> NetworkMessageBuilder<'a, 'b> {
            let start = _fbb.start_table();
            NetworkMessageBuilder {
                fbb_:   _fbb,
                start_: start,
            }
        }

        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NetworkMessage<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    #[inline]
    pub fn get_root_as_network_message<'a>(buf: &'a [u8]) -> NetworkMessage<'a> {
        flatbuffers::get_root::<NetworkMessage<'a>>(buf)
    }

    #[inline]
    pub fn get_size_prefixed_root_as_network_message<'a>(buf: &'a [u8]) -> NetworkMessage<'a> {
        flatbuffers::get_size_prefixed_root::<NetworkMessage<'a>>(buf)
    }

    #[inline]
    pub fn finish_network_message_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<NetworkMessage<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_network_message_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<NetworkMessage<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod network
